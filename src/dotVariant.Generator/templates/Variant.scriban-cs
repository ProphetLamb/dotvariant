{{~
# Copyright Miro Knejp 2021.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
~}}
{{~ ##
Inputs:
- language:
    - nullable: Either "enable" or "disable".
    - version: Integer of the form ABB where A=major and BB=minor version of the language (i.e. 703 -> 7.3)
- namespace: Namespace of the variant type, or null if in the global namespace
- name: Name of the variant type within the context of the namespace.
- diag_name: The fully qualified name of the type (without global:: alias, for diagnostic strings/messages)
- keyword: The keyword used to declare the type ("class", "struct", ...)
- in: Contains the "in" keyword if this is a readonly struct, otherwise empty ""
- nullable: The name of the type with appended nullability annotation
- mismatch_exception: The fully qualified type name of the mismatch exception
- params: Array containing all the information about the VariantOf(...) parameters:
  - name: The fully qualified name of the type. Never contains a nullability annotation.
  - diag_name: A shorter type name (without global:: qualifier, for diagnostic strings/messages, may contain nullability annotation).
  - hint: The user-provided parameter name in VariantOf
  - object_padding: The number of "object" padding fields required for this type.
  - index: The 1-based index of the type within the variant.
  - is_class: true if this is an object type (or generic with class constraint).
  - nullability: "nonnull" or "nullable".
    For classes this determines whether the parameter was originally declared as nullable or null oblivious verses not nullable.
    For value types this determines whether it's a Nullable<T>.
  - emit_implicit_cast: True if the implicit cast from option to variant should be emitted for this type.
## ~}}
{{~
emit_nullability = language.version >= 800 && language.nullable == "enable"

# The type to use for variables and function parameters
# Works with both "params" and "variant"
func value_type(type, name = null)
    if (name == null)
        name = type.name
    end
    if type.is_class
        ret emit_nullability && type.nullability == "nullable" ? (name + "?" ): name
    else
        ret type.nullability == "nullable" ? (name + "?") : name
    end
end

# The type to use for out or ref parameters
# Works with both "params" and "variant"
func outref_type(type, name = null)
    if (name == null)
        name = type.name
    end
    if type.is_class
        ret emit_nullability ? (name + "?") : name
    else
        ret type.nullability == "nullable" ? (name + "?") : name
    end
end

func func_type(param, result = "TResult")
    ret "global::System.Func<" + (value_type param) + ", " + result + ">"
end

func action_type(param)
    ret "global::System.Action<" + (value_type param) + ">"
end

# Conditionally append forgive-operator to an expression
# Works with both "params" and "variant"
func forgive(type, expression)
    if type.is_class
        ret emit_nullability && type.nullability == "nonnull" ? (expression + "!") : expression
    else
        ret expression
    end
end

# Conditionally apply a null-caolescing member access with trailing null-expression after the ??
# Works with both "params" and "variant"
func coalesce(type, expression, sub_expression, null_expression)
    if type.nullability == "nullable"
        ret expression + "?" + sub_expression + " ?? " + null_expression
    else
        ret expression + sub_expression
    end
end

func coalesce_ToString(type, expression)
    if type.nullability == "nonnull" && type.to_string_nullability == "nonnull"
        ret expression + ".ToString()"
    else
        ret expression + (type.nullability == "nullable" ? "?" : "") + ".ToString() ?? \"null\""
    end
end

func storage(param)
    ret "_x._" + param.index + ".Value"
end

func param_hint(param)
    ret param.hint
end

func annotate_NotNullWhen(param)
    if param.is_class && emit_nullability
        ret param.nullability == "nonnull" ? "[global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] " : ""
    else
        ret ""
    end
end

func annotate_NotNull(param)
    if param.is_class && emit_nullability
        ret param.nullability == "nonnull" ? "[global::System.Diagnostics.CodeAnalysis.NotNull] " : ""
    else
        ret ""
    end
end

func_params = params | array.each @(do; ret (func_type $0) + " " + $0.hint; end) | array.join ", "
action_params = params | array.each @(do; ret (action_type $0) + " " + $0.hint; end) | array.join ", "
method_modifiers = !variant.is_class ? "readonly " : ""
param_modifiers = !variant.is_class && variant.is_readonly ? "in " : ""
global_nullable = emit_nullability ? "?" : ""

readonly func_params
readonly action_params
readonly method_modifiers
readonly param_modifiers
readonly global_nullable
~}}
{{~ if language.version >= 800 ~}}
#nullable {{ language.nullable }}
{{~ end ~}}
{{~ if variant.namespace ~}}
namespace {{ variant.namespace }}
{
    {{~ end ~}}
    [global::System.Diagnostics.DebuggerTypeProxy(typeof(_VariantTypeProxy))]
    [global::System.Diagnostics.DebuggerDisplay("{_variant.AsObject}", Type = "{_variant.TypeString,nq}")]
    [global::System.Diagnostics.DebuggerNonUserCode]
    partial {{ variant.keyword }} {{ variant.name }} : global::System.IEquatable<{{ variant.name }}>
    {
        [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
        private readonly _VariantStorage _variant;

        private sealed class _VariantTypeProxy
        {
            public object{{ global_nullable }} Value { get; }
            public _VariantTypeProxy({{ variant.name }} v)
            {
                Value = v._variant.AsObject;
            }
        }

        [global::System.Diagnostics.DebuggerNonUserCode]
        private readonly struct _VariantStorage
        {
            private readonly int _n;
            private readonly Union _x;
            {{~ ##
            Variant tries to use as little space as possible by using an Explicit layout
            for its possible option types. Because Variant is a sum type there can only
            ever be a single "active" field, i.e. holding real data.

            This means we can use explicit layout and overlap those types onto the same
            area of memory. There is only one restriction that we must adhere to:

                A unmanaged field and a reference field cannot occupiy the same space.

            To ensure this the CLR switches the layout of structs containing reference
            fields from the default "Sequential" to "Auto" and seems to move all reference
            fields to the beginning of the structure. Let's look at this with a concrete
            example:

            struct A { public IntPtr i; public IntPtr j; }
            struct B { public IntPtr i; public object o; }

            Have a look at the memory layout of

            [StructLayout(LayoutKind.Explicit)]
            class Variant { [FieldOffset(0)] public A a; [FieldOffset(0)] public B b; }

            +--------+-----------------+
            | offset | Variant         |
            +--------+-----------------+
            |        | +-----+ +-----+ |
            |      0 | | A.i | | B.o | | <- ERROR
            |        | +-----+ +-----+ |
            |      8 | | A.j | | B.i | |
            |        | +-----+ +-----+ |
            +--------+-----------------+

            The line marked above shows how an object reference (B.o) is now sharing
            space with an unmanaged type (A.i). Trying to load this type will trigger a
            TypeLoadException saying Variant "contains an object field at offset 0
            that is incorrectly aligned or overlapped by a non-object field".

            The way we fix this is by wrapping A in a new struct and adding an object reference
            to it:

            struct WrapA { public A a; public object o; }

            [StructLayout(LayoutKind.Explicit)]
            class Variant { [FieldOffset(0)] private WrapA a; [FieldOffset(0)] private B b; }

            Leading to this layout:

            +--------+---------------------------+
            | offset | Variant                   |
            +--------+---------------------------+
            |        | +---------------+ +-----+ |
            |      0 | | WrapA.o       | | B.o | | <- OK
            |        | +---------------+ |     | |
            |        | | +-----------+ | +-----+ |
            |      8 | | | WrapA.a.i | | | B.i | |
            |        | | +-----------+ | +-----+ |
            |     16 | | | WrapA.a.j | |         |
            |        | | +-----------+ |         |
            |        | +---------------+         |
            +------------------------------------+

            This layout no longer causes exceptions and can be loaded but at the cost
            of extra memory consumption and unused "dummy" fields.

            We still have one issue though: where do we put the discriminator (the
            integer telling us which value is "active" in the Variant)? It needs to
            always be at the same memory location regardless of the currently active
            type. We also cannot force it to offset 0 because that's where the managed
            types will go. The solution here is an extra level of indirection:

                Put all the WrapX types inside a new struct with the explicit layout
                and leave the discriminator integer outside:

            [StructLayout(LayoutKind.Explicit)]
            struct Values
            {
                [FieldOffset(0)] public WrapA a;
                [FieldOffset(0)] public WrapB b;
                ...
                [FieldOffset(0)] public WrapN n;
            }

            class Variant { private int discriminator; private Values values; }

            +--------+-------------------------------------+
            | offset | Variant                             |
            +--------+-------------------------------------+
            |      0 | discriminator                       |
            +--------+-------------------------------------+
            |        | values                              |
            |        | +---------------------------------+ |
            |        | | +---------------+ +-----------+ | |
            |      8 | | | WrapA.o       | | WrapB.b.o | | |
            |        | | +---------------+ |           | | |
            |        | | | +-----------+ | +-----------+ | |
            |     16 | | | | WrapA.a.i | | | WrapB.b.i | | |
            |        | | | +-----------+ | +-----------+ | |
            |     24 | | | | WrapA.a.j | |               | |
            |        | | | +-----------+ |               | |
            |        | | +---------------+               | |
            |        | +---------------------------------+ |
            +--------+-------------------------------------+

            While this results in some overhead, as the Variant's size is
            the sum of max(object fields) + max(non-object fields) for all
            possible values it can hold, it allows for the elision of boxing
            for value types and has zero space overhead if it only stores
            unmanaged value types.
            ## ~}}

            {{~ ## STORAGE CONSTRUCTORS ## ~}}
            {{~ for $p in params ~}}
            public _VariantStorage({{ value_type $p }} {{ $p.hint }})
            {
                _n = {{ $p.index }};
                _x = new Union({{ $p.hint }});
                {{~ # Force a reference to the VariantOf function so the user doesn't get IDE0051 "Private member 'VariantOf' is unused." ~}}
                VariantOf({{ params | array.each @(do; ret forgive $0 "default"; end) | array.join ", " }});
            }
            {{~ end ~}}

            {{~ ## UNION TYPE ## ~}}
            [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Explicit)]
            [global::System.Diagnostics.DebuggerNonUserCode]
            private readonly struct Union
            {
                {{~ ## UNION MEMBERS ## ~}}
                {{~ for $p in params ~}}
                [global::System.Runtime.InteropServices.FieldOffset(0)]
                public readonly Union{{ $p.index }} _{{ $p.index }};
                {{~ end ~}}

                {{~ ## UNION CONSTRUCTORS ## ~}}
                {{~ for $p in params ~}}
                public Union({{ value_type $p }} value)
                {
                    {{~ for $other in params | array.remove_at ($p.index - 1) ~}}
                    _{{ $other.index }} = default;
                    {{~ end ~}}
                    _{{ $p.index }} = new Union{{ $p.index }}(value);
                }
                {{~ end ~}}

                {{~ ## PER-TYPE WRAPPERS WITH PADDING ## ~}}
                {{~ for $p in params ~}}
                [global::System.Diagnostics.DebuggerNonUserCode]
                public readonly struct Union{{ $p.index }}
                {
                    public readonly {{ value_type $p }} Value;
                    {{~ for $dummy in (1..$p.object_padding) limit:$p.object_padding ~}}
                    public readonly object _dummy{{ $dummy }};
                    {{~ end ~}}

                    public Union{{ $p.index }}({{ value_type $p }} value)
                    {
                        {{~ for $dummy in (1..$p.object_padding) limit:$p.object_padding ~}}
                        _dummy{{ $dummy }} = null{{ emit_nullability ? "!" : "" }};
                        {{~ end ~}}
                        Value = value;
                    }
                }
                {{~ end ~}}
            }

            {{~ ## UNION IsEmpty ## ~}}
            public bool IsEmpty => _n == 0;

            {{~ ## UNION TypeString ## ~}}
            public string TypeString
            {
                get
                {
                    switch (_n)
                    {
                        case 0: return "<empty>";
                        {{~ for $p in params ~}}
                        case {{ $p.index }}: return "{{ $p.diag_name }}";
                        {{~ end ~}}
                        default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                    }
                }
            }

            {{~ ## UNION ValueString ## ~}}
            public string ValueString
            {
                get
                {
                    switch (_n)
                    {
                        case 0: return "<empty>";
                        {{~ for $p in params ~}}
                        case {{ $p.index }}: return {{ coalesce_ToString $p (storage $p) }};
                        {{~ end ~}}
                        default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                    }
                }
            }

            {{~ ## UNION AsObject ## ~}}
            public object{{ global_nullable }} AsObject
            {
                get
                {
                    switch (_n)
                    {
                        case 0: return null;
                        {{~ for $p in params ~}}
                        case {{ $p.index }}: return {{ storage $p }};
                        {{~ end ~}}
                        default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                    }
                }
            }

            {{~ ## UNION Equals ## ~}}
            public bool Equals(in _VariantStorage other)
            {
                if (_n != other._n)
                {
                    return false;
                }
                switch (_n)
                {
                    case 0: return true;
                    {{~ for $p in params ~}}
                    {{~ $i = $p.index ~}}
                    case {{ $i }}: return global::System.Collections.Generic.EqualityComparer<{{ $p.name }}>.Default.Equals({{ storage $p }}, other.{{ storage $p }});
                    {{~ end ~}}
                    default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                }
            }

            {{~ ## UNION GetHashCode ## ~}}
            public readonly override int GetHashCode()
            {
                unchecked
                {
                    switch (_n)
                    {
                        case 0:
                            return 0;
                        {{~ for $p in params ~}}
                        {{~ $i = $p.index ~}}
                        case {{ $i }}:
                            {{~ if runtime.has_hash_code ~}}
                            return global::System.HashCode.Combine({{ storage $p }});
                            {{~ else ~}}
                            return {{ coalesce $p (storage $p) ".GetHashCode()" "0"}};
                            {{~ end ~}}
                        {{~ end ~}}
                        default:
                            throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                    }
                }
            }

            {{~ ## UNION TryMatch ## ~}}
            {{~ for $p in params ~}}
            public bool TryMatch({{ annotate_NotNullWhen $p }}out {{ outref_type $p }} {{ $p.hint }})
            {
                {{ $p.hint }} = _n == {{ $p.index }} ? {{ storage $p }} : default;
                return _n == {{ $p.index }};
            }
            {{~ end ~}}

            {{~ ## UNION Match(Action) ## ~}}
            public void Match({{ action_params }}, global::System.Action _)
            {
                switch (_n)
                {
                    case 0: _(); break;
                    {{~ for $p in params ~}}
                    case {{ $p.index }}: {{ $p.hint }}({{ storage $p }}); break;
                    {{~ end ~}}
                    default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                }
            }

            {{~ ## UNION Match(Action) ## ~}}
            public void Match({{ action_params }})
            {
                switch (_n)
                {
                    case 0: throw new global::System.InvalidOperationException("{{ variant.name }} is empty.");
                    {{~ for $p in params ~}}
                    case {{ $p.index }}: {{ $p.hint }}({{ storage $p }}); break;
                    {{~ end ~}}
                    default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                }
            }

            {{~ ## UNION Match(Func) ## ~}}
            public TResult Match<TResult>({{ func_params }}, global::System.Func<TResult> _)
            {
                switch (_n)
                {
                    case 0: return _();
                    {{~ for $p in params ~}}
                    case {{ $p.index }}: return {{ $p.hint }}({{ storage $p }});
                    {{~ end ~}}
                    default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                }
            }

            {{~ ## UNION Match(Func) ## ~}}
            public TResult Match<TResult>({{ func_params }})
            {
                switch (_n)
                {
                    case 0: throw new global::System.InvalidOperationException("{{ variant.name }} is empty.");
                    {{~ for $p in params ~}}
                    case {{ $p.index }}: return {{ $p.hint }}({{ storage $p }});
                    {{~ end ~}}
                    default: throw new global::System.InvalidOperationException("{{ variant.name }} is in a corrupted state.");
                }
            }
        }

        {{~ ## VARIANT CONSTRUCTORS ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Create a {{ variant.name }} with a value of type <see cref="{{ $p.name }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">The value to initlaize the variant with.</param>
        public {{ variant.name }}({{ value_type $p }} {{ $p.hint }}) => _variant = new _VariantStorage({{ $p.hint }});
        {{~ end ~}}

        {{~ ## IMPLICIT CONVERSIONS ## ~}}
        {{~ for $p in params ~}}
        {{~ if $p.emit_implicit_cast ~}}
        /// <summary>
        /// Create a {{ variant.name }} with a value of type <see cref="{{ $p.name }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">The value to initlaize the variant with.</param>
        public static implicit operator {{ variant.name }}({{ value_type $p }} {{ $p.hint }}) => new {{ name }}({{ $p.hint }});
        {{~ end ~}}
        {{~ end ~}}

        {{~ # STATIC CREATE FACTORIES ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Create a {{ variant.name }} with a value of type <see cref="{{ $p.name }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">The value to initlaize the variant with.</param>
        public static {{ variant.name }} Create({{ value_type $p }} {{ $p.hint }}) => new {{ name }}({{ $p.hint }});
        {{~ end ~}}

        {{~ ## VARIANT IsEmpty ## ~}}
        /// <summary>
        /// <see langword="true"/> if {{ variant.name }} was constructed without a value.
        /// </summary>
        {{~ if !variant.is_class ~}}
        /// <remarks>
        /// Because {{ variant.name }} is a value type, its default constructor cannot be disabled.
        /// A default-constructed {{ variant.name }} will always have a <see cref="IsEmpty"/> value of <see langword"true"/>
        /// and never satisfy any matching attempts except for the wildcard <c>_</c> parameter.
        /// </remarks>
        {{~ end ~}}
        public {{ method_modifiers }}bool IsEmpty => _variant.IsEmpty;

        {{~ ## VARIANT Equals ## ~}}
        public {{ method_modifiers }}override bool Equals(object{{ global_nullable }} other) => other is {{ variant.name }} v && Equals(v);
        public {{ method_modifiers }}bool Equals({{ value_type variant }} other)
            => {{ if variant.is_class; "!(other is null) && "; end }}_variant.Equals(other._variant);

        public static bool operator ==({{ param_modifiers; value_type variant }} lhs, {{ param_modifiers; value_type variant }} rhs)
            => {{ coalesce variant "lhs" ".Equals(rhs)" "(rhs is null)" }};

        public static bool operator !=({{ param_modifiers; value_type variant }} lhs, {{ param_modifiers; value_type variant }} rhs)
            => !(lhs == rhs);

        {{~ ## VARIANT GetHashCode ## ~}}
        public {{ method_modifiers }}override int GetHashCode() => _variant.GetHashCode();

        {{~ ## VARIANT ToString ## ~}}
        public {{ method_modifiers }}override string ToString() => _variant.ValueString;

        {{~ ## VARIANT Match(T) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Retrieve the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/>,
        /// otherwise throw <see cref="{{ mismatch_exception }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">Receives the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <exception cref="{{ mismatch_exception }}">{{ variant.name }} does not contain a value of type <see cref="{{ $p.name }}"/></exception>
        public {{ method_modifiers }}void Match({{ annotate_NotNull $p }}out {{ outref_type $p }} {{ $p.hint }})
        {
            if (!_variant.TryMatch(out {{ forgive $p $p.hint }}))
            {
                throw new {{ mismatch_exception }}(expected: "{{ $p.diag_name }}", actual: _variant.TypeString);
            }
        }
        {{~ end ~}}

        {{~ ## VARIANT TryMatch(T) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Retrieve the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">Receives the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <returns><see langword="true"/> if {{ variant.name }} contained a value of type <see cref="{{ $p.name }}"/>.</returns>
        public {{ method_modifiers }}bool TryMatch({{ annotate_NotNullWhen $p }}out {{ outref_type $p }} {{ $p.hint }})
            => _variant.TryMatch(out {{ $p.hint }});
        {{~ end ~}}

        {{~ ## VARIANT TryMatch(Action<T>) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Invoke a delegate with the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <returns><see langword="true"/> if {{ variant.name }} contained a value of type <see cref="{{ $p.name }}"/>.</returns>
        /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.hint }}"> is rethrown.</exception>
        public {{ method_modifiers }}bool TryMatch({{ action_type $p }} {{ $p.hint }})
        {
            bool result = _variant.TryMatch(out {{ outref_type $p }} _value);
            if (result)
            {
                {{ $p.hint }}({{ forgive $p "_value" }});
            }
            return result;
        }
        {{~ end ~}}

        {{~ ## VARIANT Match(Action<T>) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Invoke a delegate with the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/>,
        /// otherwise throw <see cref="{{ mismatch_exception }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <exception cref="{{ mismatch_exception }}">{{ variant.name }} does not contain a value of type <see cref="{{ $p.name }}"/></exception>
        /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.hint }}"> is rethrown.</exception>
        public {{ method_modifiers }}void Match({{ action_type $p }} {{ $p.hint }})
        {
            if (_variant.TryMatch(out {{ outref_type $p }} _value))
            {
                {{ $p.hint }}({{ forgive $p "_value" }});
            }
            else
            {
                throw new {{ mismatch_exception }}(expected: "{{ $p.diag_name }}", actual: _variant.TypeString);
            }
        }
        {{~ end ~}}

        {{~ ## VARIANT Match(Action<T>) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Invoke a delegate with the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/>,
        /// otherwise invoke an alternative delegate.
        /// </summary>
        /// <param name="{{ $p.hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <param name="_">The delegate to invoke if the stored value is of a different type.</param>
        /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.hint }}"> or <paramref name="_"> is rethrown.</exception>
        public {{ method_modifiers }}void Match({{ action_type $p }} {{ $p.hint }}, global::System.Action _)
        {
            if (_variant.TryMatch(out {{ outref_type $p }} _value))
            {
                {{ $p.hint }}({{ forgive $p "_value" }});
            }
            else
            {
                _();
            }
        }
        {{~ end ~}}

        {{~ ## VARIANT Match(Func<T, R>) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Invoke a delegate with the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/> and return the result,
        /// otherwise throw <see cref="{{ mismatch_exception }}"/>.
        /// </summary>
        /// <param name="{{ $p.hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <returns>The value returned from invoking <paramref name="{{ $p.hint }}"/>.</returns>
        /// <exception cref="{{ mismatch_exception }}">{{ variant.name }} does not contain a value of type <see cref="{{ $p.name }}"/></exception>
        /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.hint }}"> is rethrown.</exception>
        public {{ method_modifiers }}TResult Match<TResult>({{ func_type $p }} {{ $p.hint }})
            => _variant.TryMatch(out {{ outref_type $p }} _value) ? {{ $p.hint }}({{ forgive $p "_value" }}) : throw new {{ mismatch_exception }}(expected: "{{ $p.diag_name }}", actual: _variant.TypeString);
        {{~ end ~}}

        {{~ ## VARIANT Match(Func<T, R>, R) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Invoke a delegate with the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/> and return the result,
        /// otherwise return a provided value.
        /// </summary>
        /// <param name="{{ $p.hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <param name="_">The value to return if the stored value is of a different type.</param>
        /// <returns>The value returned from invoking <paramref name="{{ $p.hint }}"/>, or <paramref name="default"/>.</returns>
        /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.hint }}"> or <paramref name="other"> is rethrown.</exception>
        public {{ method_modifiers }}TResult Match<TResult>({{ func_type $p }} {{ $p.hint }}, TResult _)
            => _variant.TryMatch(out {{ outref_type $p }} _value) ? {{ $p.hint }}({{ forgive $p "_value" }}) : _;
        {{~ end ~}}

        {{~ ## VARIANT Match(Func<T, R>, Func<R>) ## ~}}
        {{~ for $p in params ~}}
        /// <summary>
        /// Invoke a delegate with the value stored within {{ variant.name }} if it is of type <see cref="{{ $p.name }}"/> and return the result,
        /// otherwise invoke an alternative delegate and return its result.
        /// </summary>
        /// <param name="{{ $p.hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ $p.name }}"/>.</param>
        /// <param name="_">The delegate to invoke if the stored value is of a different type.</param>
        /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.hint }}"> or <paramref name="_"> is rethrown.</exception>
        public {{ method_modifiers }}TResult Match<TResult>({{ func_type $p }} {{ $p.hint }}, global::System.Func<TResult> _)
            => _variant.TryMatch(out {{ outref_type $p }} _value) ? {{ $p.hint }}({{ forgive $p "_value" }}) : _();
        {{~ end ~}}

        {{~ ## VARIANT Match(Action<A>, Action<B>, ...) ## ~}}
        /// <summary>
        /// Invoke the delegate whose parameter type matches that of the value stored within {{ variant.name }},
        /// and throw an exception if {{ variant.name }} is empty.
        /// </summary>
        {{~ for $p in params ~}}
        /// <param name="{{ $p.hint }}">The delegate to invoke if the stored value is of type <see cref="{{ $p.name }}"/>.</param>
        {{~ end ~}}
        /// <exception cref="global::System.InvalidOperationException">{{ variant.name }} is empty.</exception>
        /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
        public {{ method_modifiers }}void Match({{ action_params }})
            => _variant.Match({{ params | array.each @param_hint | array.join ", " }});

        {{~ ## VARIANT Match(Action<A>, Action<B>, ..., empty) ## ~}}
        /// <summary>
        /// Invoke the delegate whose parameter type matches that of type of the value stored within {{ variant.name }},
        /// and invoke a special delegate if {{ variant.name }} is empty.
        /// </summary>
        {{~ for $p in params ~}}
        /// <param name="{{ $p.hint }}">The delegate to invoke if the stored value is of type <see cref="{{ $p.name }}"/>.</param>
        {{~ end ~}}
        /// <param name="_">The delegate to invoke if {{ variant.name }} is empty.</param>
        /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
        public {{ method_modifiers }}void Match({{ action_params }}, global::System.Action _)
            => _variant.Match({{ params | array.each @param_hint | array.join ", "  }}, _);

        {{~ ## VARIANT Match(Func<A, R>, Func<B, R>, ...) ## ~}}
        /// <summary>
        /// Invoke the delegate whose parameter type matches that of the value stored within {{ variant.name }} and return the result,
        /// and throw an exception if {{ variant.name }} is empty.
        /// </summary>
        {{~ for $p in params ~}}
        /// <param name="{{ $p.hint }}">The delegate to invoke if the stored value is of type <see cref="{{ $p.name }}"/>.</param>
        {{~ end ~}}
        /// <exception cref="global::System.InvalidOperationException">{{ variant.name }} is empty.</exception>
        /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
        /// <typeparam name="TResult">The return type of all delegates, and by extension the return type of this function.</typeparam>
        public {{ method_modifiers }}TResult Match<TResult>({{ func_params }})
            => _variant.Match({{ params | array.each @param_hint | array.join ", "  }});

        {{~ ## VARIANT Match(Func<A, R>, Func<B, R>, ..., empty) ## ~}}
        /// <summary>
        /// Invoke the delegate whose parameter type matches that of type of the value stored within {{ variant.name }} and return the result,
        /// and invoke a special delegate if {{ variant.name }} is empty and return its result.
        /// </summary>
        {{~ for $p in params ~}}
        /// <param name="{{ $p.hint }}">The delegate to invoke if the stored value is of type <see cref="{{ $p.name }}"/>.</param>
        {{~ end ~}}
        /// <param name="_">The delegate to invoke if {{ variant.name }} is empty.</param>
        /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
        /// <typeparam name="TResult">The return type of all delegates, and by extension the return type of this function.</typeparam>
        public {{ method_modifiers }}TResult Match<TResult>({{ func_params }}, global::System.Func<TResult> _)
            => _variant.Match({{ params | array.each @param_hint | array.join ", "  }}, _);

        {{~ ## VARIANT Match(Func<A, R>, Func<B, R>, ...) ## ~}}
    }
{{~ if namespace ~}}
}
{{~ end ~}}
